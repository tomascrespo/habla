package com.crpilarsoubrier.habla.data;


import android.content.Context;
import android.content.res.AssetManager;
import android.os.Environment;
import android.util.Log;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.room.Database;
import androidx.room.Room;
import androidx.room.RoomDatabase;
import androidx.sqlite.db.SupportSQLiteDatabase;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Arrays;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

@Database(entities = {Picto.class}, version = 1, exportSchema = false)
public abstract class PictoRoomDatabase extends RoomDatabase{

    public abstract PictoDao pictoDao();
    private static final String  ALBUM_NAME = "Habla";
    private static final String  ASSETS_BUILTIN_DATA_DIRECTORY = "pictos";
    private static volatile PictoRoomDatabase INSTANCE;
    private static final int NUMBER_OF_THREADS = 4;
    static final ExecutorService databaseWriteExecutor =
            Executors.newFixedThreadPool(NUMBER_OF_THREADS);

    static PictoRoomDatabase getDatabase(final Context context) {
        if (INSTANCE == null) {
            synchronized (PictoRoomDatabase.class) {
                if (INSTANCE == null) {
                    INSTANCE = Room.databaseBuilder(context.getApplicationContext(),
                            PictoRoomDatabase.class, "picto_database")
                            //.addCallback(sRoomDatabaseCallback) // Through a function
                            .addCallback(new RoomDatabase.Callback()  { // Inline callback to allow using context
                                @Override
                                public void onCreate(@NonNull SupportSQLiteDatabase db){
                                    super.onCreate(db);
                                    //context.fileList();
                                    populateDatabase(context);
                                }
                    })
                            .build();
                }
            }
            // Should we load sample data here?
        }
        return INSTANCE;
    }

    /**
     * * We insert a category for each folder in /assets/pictos and a we insert a Picto
     * * for each file.
     * * We also copy the files from asset to AlbumStorageDir, following the android developers
     * * best practices.
     * * @todo Re-evalute using AlbumStorageDir, InternalStorage or ExternalStorage
     */
    private static void populateDatabase(Context context) {

            databaseWriteExecutor.execute(() -> {
                // Populate the database in the background.
                // If you want to start with more words, just add them.
                PictoDao dao = INSTANCE.pictoDao();
                dao.deleteAll();

                File externalFileDir = getAppSpecificAlbumStorageDir(context, ALBUM_NAME);
                Log.println(Log.INFO, "populateDatabase", "externalFileDir: " + externalFileDir.toString());

                // Copy every file in the specified directory recursively
                loadBuiltinPictos(ASSETS_BUILTIN_DATA_DIRECTORY, externalFileDir, context, dao);

            });
    }

    private static void loadBuiltinPictos(String assetDirectory, File targetDirectory , Context context, PictoDao dao){

        AssetManager assetManager = context.getAssets();
        String[] files = null;
        try {
            files = assetManager.list(assetDirectory);
            Log.println(Log.INFO, "populateDatabase", "files: " + Arrays.toString(files));
        } catch (IOException e) {
            Log.e("populateDatabase", "Failed to get asset file list.", e);
        }
        for(String filename : files) {
            String inFilename = assetDirectory + "/" + filename;
            InputStream in = null;
            OutputStream out = null;
            if (filename.contains(".")) { // It's a file, not a directory
                try {
                    Log.println(Log.INFO, "populateDatabase", inFilename + " is a file, let's copy it");
                    in = assetManager.open(inFilename);

                    // Create and insert the picto into the database
                    Picto picto = new Picto(filename, filename.split("\\.")[0].replace("_", " ").replace("-"," ").toUpperCase());
                    long rowId = dao.insert(picto); // Get the autogenerated insert ID
                    filename = Long.toString(rowId) + "." +  filename.split("\\.")[1]; // Filename will be insertID.original extension (i.e. 27.png)
                    picto.setId(rowId); // My picto object must have the same ID as the row to allow update it
                    picto.setPicFilePath(filename); // New filename for the file image, id + original extension
                    dao.update(picto);
                    File outFile = new File(targetDirectory, filename);
                    out = new FileOutputStream(outFile);
                    copyFile(in, out);
                    in.close();
                    in = null;
                    out.flush();
                    out.close();
                    out = null;
                } catch (IOException e) {
                    Log.e("populateDatabase", "Failed to copy asset file: " + filename, e);
                }
            } else {
                loadBuiltinPictos(assetDirectory + "/" + filename, targetDirectory, context, dao);
            }
        }

    }

    private static void copyFile(InputStream in, OutputStream out) throws IOException {
        byte[] buffer = new byte[1024];
        int read;
        while((read = in.read(buffer)) != -1){
            out.write(buffer, 0, read);
        }
    }

    @Nullable
    static File getAppSpecificAlbumStorageDir(Context context, String albumName) {
        // Get the pictures directory that's inside the app-specific directory on
        // external storage.
        File file = new File(context.getExternalFilesDir(
                Environment.DIRECTORY_PICTURES), albumName);
        if (file == null || !file.mkdirs()) {
            Log.e("populateDatabase", "Directory not created");
        }
        return file;
    }



}
